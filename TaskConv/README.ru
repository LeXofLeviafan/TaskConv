TaskConvertor конвертирует задачи с групповыми тестами из известных форматов в формат тестов DL.
Версия 1.2.2


usage: TaskConv {-h|[-d] <путь>} [[-w] <путь>] [опции]
 -a,--auto                определить тип задачи автоматически при
                          неопределённом результате
 -d,--directory <путь>    папка задачи (обязательная)
 -h,--help                выводит это сообщение
 -i,--infiles-only        обрабатывать только входные файлы (для задач без
                          выходных файлов)
 -k,--keep                при использовании с --move, не удалить рекурсивно
                          пустые папки из папки задачи после обработки файлов
 -l,--level <int>         уровень глубины (по умолчанию 0)
 -m,--move                перемещать файлы вместо копирования
 -n,--name <название>     название задачи (заданное, а не определяемое)
 -o,--output <имя файла>  файл вывода (результат); по умолчанию "marks.txt"
 -q,--quiet               подавлять вывод всех сообщений
 -t,--type <префикс>      требуемый префикс типа задачи (IOI, CEOI и т.п.)
 -v,--verbose             подробный вывод
 -w,--workdir <путь>      директория вывода (по умолчанию папка задачи)


Опции с аргументами могут быть заданы следующими способами:
 -d TaskDir
 -dTaskDir
 --directory=TaskDir
 --directory TaskDir
Также можно писать короткие опции вместе:
 TaskConv -mvco test.txt --directory taskpath

TaskType - требуемый префикс имени типа задачи. Т.е., "-t IOI" ограничит выбор программы типами с
именами, начинающимися с "IOI": "IOI", "IOI11", "IOI10a", "IOI 2013" и т.д.

Также можно использовать свободные аргументы (без опций); такие аргументы обрабатываются после
всех остальных, по следующим правилам:
 - если папка задачи (-d) не была задана, считается, что аргумент задаёт её
 - иначе, если директория вывода (-w) не была задана, считается, что аргумент задаёт её
 - иначе аргумент нелегален и программа откажется работать

Уровень глубины - количество уровней, на которое нужно опуститься из TaskDir, чтобы добраться до
задачи; а именно, ВСЕ подпапки на этом уровне считаются задачами ОДНОГО ТИПА. Если ЛЮБАЯ из них
не пройдёт определение типа, он не определится для всей группы.
Пример применения:
	задачи размещены так:    'Baltica2011/Day 1/task1'
	запускаем программу так: 'TaskConv Baltica2011 -l2'


Файлы в папке "DB/" соответствуют известным типам. Можно спокойно добавлять свои (но обязательно
проверять их на правильность перед использованием). Их формат следующий:

1-я строка = шаблон input файла
2-я строка = шаблон output файла
Оба шаблона используют символ '/' как разделитель директорий.

детали шаблона:
	${varname} - переменная
	$[varname] - переменная может быть опущена (только SS или SL)
переменные:
	TaskName - название задачи
	S - номер группы тестов
	SS - номер теста в группе
	SL - буква теста в группе (Alphabet[SS])

TaskName – единственная переменная, не имеющая отношения к структуре тестов.
Если программе по какой-то причине не удаётся определить её, можно задать значение опцией "-n".

Необязательный файл ".cfg" содержит символы для проверки путей:
	В первой строке содержатся правильные символы для TaskName (по умолчанию латинские буквы).
Проверка путей регистронечувствительна.


Если для задачи не удалось определить подходящий тип, программа откажется работать. Можно
попробовать запустить её с подробным выводом (-v), чтобы узнать, почему это случилось.

Если для задача определилось более одного типа, программа сортирует типы по количеству найденных
input файлов (если была использована -i) или пар input/output (в противном случае). После этого,
если программа работает в автоматическом режиме (-a), она просто выберет тип с наибольшим
количеством совпадений; в противном случае она запросит ввод пользователя (0 для отмены, 1 для
типа по умолчанию и т.д.).


Код был модифицирован для вызова из внешнего Java-кода. Main теперь реализует Callable<String>,
который генерирует RageExitException, вместо того чтобы останавливать JVM. Пример: см. 'test/'.
